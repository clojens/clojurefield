{
  "author": {
    "name": "Michael Bradley, Jr.",
    "email": "michaelsbradleyjr@gmail.com",
    "url": "https://github.com/michaelsbradleyjr"
  },
  "name": "clojure-script",
  "description": "seamless integration between NodeJS and ClojureScript",
  "licenses": [
    {
      "type": "EPL",
      "url": "http://michaelsbradleyjr.github.com/node-clojurescript/licenses/epl-v10.html"
    }
  ],
  "keywords": [
    "clojure",
    "clojurescript",
    "clojure-script",
    "java"
  ],
  "version": "0.1.4",
  "homepage": "http://michaelsbradleyjr.github.com/node-clojurescript",
  "repository": {
    "type": "git",
    "url": "git://github.com/michaelsbradleyjr/node-clojurescript.git"
  },
  "main": "./index.js",
  "bin": {
    "ncljsc": "./bin/ncljsc",
    "nlein": "./bin/nlein"
  },
  "scripts": {
    "test": "./node_modules/coffee-script/bin/cake test",
    "postinstall": "sh ./scripts/postinstall.sh"
  },
  "engines": {
    "node": "~0.6"
  },
  "dependencies": {
    "cli-color": ">=0.1.6",
    "commander": ">=0.6.0",
    "java": ">=0.0.3",
    "node-uuid": ">=1.3.3",
    "restify": ">=1.4.1",
    "shelljs": "0.0.5pre4",
    "superagent": ">=0.4.1",
    "temporary": ">=0.0.2"
  },
  "devDependencies": {
    "chai": ">=0.4.2",
    "clog": ">=0.1.2",
    "coffee-script": ">=1.2.0",
    "docco": "https://github.com/michaelsbradleyjr/docco/tarball/master",
    "gfms": ">=0.0.3",
    "mocha": "https://github.com/michaelsbradleyjr/mocha/tarball/check-ENOENT-1.0.3",
    "nopt": ">=1.0.10",
    "sinon": ">=1.3.1",
    "sinon-chai": ">=1.1.0",
    "touch": ">=0.0.1",
    "underscore": ">=1.3.1",
    "underscore.string": ">=2.0.0",
    "watch": ">=0.5.1"
  },
  "optionalDependencies": {},
  "directories": {
    "lib": "./lib",
    "test": "./test"
  },
  "readme": "[![Build Status](https://secure.travis-ci.org/michaelsbradleyjr/node-clojurescript.png?branch=master)](http://travis-ci.org/michaelsbradleyjr/node-clojurescript)\n\n# node-clojurescript\n\n[node-clojurescript](https://github.com/michaelsbradleyjr/node-clojurescript) aims to provide seamless integration between [NodeJS](http://nodejs.org/) and [ClojureScript](https://github.com/clojure/clojurescript). This is a young project, started in May 2012, it's under active development and welcomes participation by the NodeJS and [Clojure](http://clojure.org) communities.\n\nPackages are available on the [npm](http://npmjs.org/) registry: &nbsp;[clojure-script](http://search.npmjs.org/#/clojure-script).\n\n\n## Description\n\nThe ClojureScript library ships with some basic mechanisms for creating compiled scripts suitable for use with NodeJS. But more is possible, and this library aims to make compiling, loading and running `.cljs` scripts a breeze, in the same manner that [CoffeeScript](http://coffeescript.org) `.coffee` files can be used transparently in the development of NodeJS-backed applications.\n\n\n## Quick Start\n\nWant to get started? There are some [prerequisites](#prerequisites), but if you'd prefer to trouble with those later:\n\n```bash\n$ npm install -g clojure-script\n```\n\nIf you get an error message from npm, it means you need to review the *[Prerequisites](#prerequisites)* section of this README.<br />Let's continue...\n\n```bash\n$ touch hello.cljs && vim hello.cljs\n```\n\nNow paste in something like:\n\n```clojure\n(ns hello\n  (:require [cljs.nodejs :as nodejs]))\n\n(defn greet [n]\n  (println (str \"Hello, \" n)))\n  \n(nodejs/next-tick\n  (fn []\n    (greet \"World!\")))\n```\n\nSave it, and leave the editor open. In another terminal, navigate to the directory where you created `hello.cljs` and do:\n\n```bash\n$ ncljsc hello.cljs\n```\n\nWhen you invoke `ncljsc`, it fires up the JVM, the ClojureScript compiler and the [Google Closure Compiler](https://developers.google.com/closure/compiler). This means the compilation will seem *slow*, even *really slow* (10+ seconds), especially if you're used to the sub-second compile times of CoffeeScript. That's expected, and the issue will be revisited in the *[Faster, faster!](#faster-faster)* section below.\n\n**N.B.** the compiled JavaScript will be evaluated by the NodeJS (V8) runtime, not by the JVM.\n\nYou should eventually see printed in your terminal:\n\n```bash\n$ ncljsc hello.cljs\nHello, World!\n```\n\nNow replace the contents of `hello.cljs` with:\n\n```clojure\n(ns hello\n  (:require [cljs.nodejs :as nodejs]\n            [clojure.string :as string]))\n\n(def http\n  (nodejs/require \"http\"))\n\n(def server (.createServer http\n   (fn [req, res]\n     (.writeHead res 200 (clj->js {:Content-Type \"text/plain\"}))\n     (.end res \"Hello, World\\n\"))))\n\n(.listen server 4200 \"127.0.0.1\")\n\n(println \"Server running at http://127.0.0.1:4200\")\n\n;; Helper\n(defn clj->js\n  \"Recursively transforms ClojureScript maps into Javascript objects,\n   other ClojureScript colls into JavaScript arrays, and ClojureScript\n   keywords into JavaScript strings. Credit:\n   http://mmcgrana.github.com/2011/09/clojurescript-nodejs.html\"\n  [x]\n  (cond\n    (string? x) x\n    (keyword? x) (name x)\n    (map? x) (.-strobj (reduce (fn [m [k v]]\n               (assoc m (clj->js k) (clj->js v))) {} x))\n    (coll? x) (apply array (map clj->js x))\n    :else x))\n```\n\nSave it, then rerun `ncljsc hello.cljs` and point your browser to [localhost:4200](http://127.0.0.1:4200).\n\nDid it work? Cool! &nbsp;(maybe submit an [issue](https://github.com/michaelsbradleyjr/node-clojurescript/issues) if it didn't)\n\n### *Faster, faster!*\n\nThe slow compile times mentioned above are owing to startup time of the JVM, plus the time to initially load the two underlying compilers (ClojureScript and Google Closure). This is an annoying problem...\n\n*Problem solved!* &nbsp;Starting with `v0.1.4`, node-clojurescript offers a way to compile against a long-running, \"detached\" JVM server:\n\n```bash\n$ ncljsc --server 4242\n```\n\nInvoke the command above and leave the terminal open (or run it in a [tmux](http://tmux.sourceforge.net/) or screen session). You don't need to navigate to a particular path before starting it, bu you need to leave it running. After 10+ seconds you should see:\n\n```bash\n$ ncljsc --server 4242\nStarting up, please wait...\n\nInitial build completed, JVM and compiler are primed and ready!\nDetached JVM server listening at http://127.0.0.1:4242/\n```\n\nIf you see something about a `DTraceProviderBindings` error, just ignore it as it's [harmless](https://github.com/mcavage/node-restify/issues/100). Depending on your platform, no error may be reported.\n\nNow open another terminal and go back to the directory where you created `hello.cljs`. Then do:\n\n```bash\n$ ncljsc --client 4242 hello.cljs\n```\n\nYou should notice a marked difference in the time required for the script to run. Once the `--server` JVM is \"hot\", compile times should take only a few seconds, instead of 10+ seconds. That's because the `--client` process does not start its own JVM.\n\n#### How does it work?\n\nThe `--server` process accepts \"build requests\" over HTTP, listening on `localhost` at the specified port. The `--client` then makes synchronous or asynchronous requests (depending on how it's invoked). And that's it: from the perspective of the end-user, the only difference is that these \"remote\" builds happen more quickly than \"local\" builds. Overall usage of `ncljsc` is the same whether you run remote or local builds.\n\n#### A few notes:\n\n* This feature is under active development and won't always work correctly, e.g. errors may not always make it back to the client and the return value of a build may be an empty string. It's best to keep an eye on the terminal output of the server process for signs of trouble.\n* You may use whatever port number you prefer, as long as the client and server use the same port.\n* Requests are restricted to the `localhost` interface. *(security)*\n* There is a transparent exchange of credentials hard-wired into the client-server logic, so that arbitrary processes can't make build requests. *(security)*\n* Aforesaid \"credentials exchange\" requires server and client processes to be run as the same user. *(security)*\n* Credentials aren't persistent, so if the server process is bounced (you restart it, maybe it crashed), client processes must be restarted if they're long-running and will attempt further build requests. *(security?)*\n* Don't use the client-server mode in a production environment. *(goes without saying?)*\n\n\n### Automatic re-compiles\n\nIt's 2012 and you shouldn't *have* to manually re-run your scripts while you're developing them. And you don't!\n\nAfter some experimentation, [supervisor](https://github.com/isaacs/node-supervisor) seems (to the author) to be the simplest and most flexible NodeJS-based tool for automatically re-starting scripts in a development workflow. Make sure to install it globally: `npm install -g supervisor`.\n\nWith `supervisor` installed and a `ncljsc --server` process running, revisit the directory where you created `hello.cljs` and do:\n\n```bash\n$ supervisor -w hello.cljs -n exit -x ncljsc -- --client 4242 hello.cljs \n```\n\nThat's a lot of flags for a single command, but see `supervisor --help` and you'll soon have the hang of it. Note that we're making use of `--client 4242`, which is proper to `ncljsc`, not `supervisor`.\n\nNow edit `hello.cljs` and watch what happens when you save it. *Fantastic!* &nbsp; It compiles quickly, and will do so repeatedly whenever you save changes, so long as you keep `supervisor` running.\n\n### Compiling to disk\n\nIn addition to running `.cljs` scripts, `ncljsc` can also be used to write compiled JavaScript to disk. For example:\n\n**saves to `hello.js` in the same directory** (local build)\n```bash\n$ ncljsc --compile hello.cljs\n```\n\n**saves to `myscript/hello.js` in the same directory** (remote build)\n```bash\n$ ncljsc --compile --output myscript --client 4242 hello.cljs\n```\n\n**re-compiles and re-saves when changes are made** (remote build)\n```bash\n$ supervisor -w hello.cljs -n exit -x ncljsc -- --client 4242 --compile hello.cljs \n```\n\n### More options\n\nThe `ncljsc` command provides additional capabilities. Try:\n\n```bash\n$ ncljsc --help\n```\n\nNot all of the features have been implemented yet. Also, you'll notice that `ncljsc` provides built-in `--watch` and `--watch-deps` options. Those do work, but there are some outstanding [bugs](https://github.com/joyent/node/issues/3172) related to NodeJS's `fs.watch` facility. As such, it seemed better to propose `supervisor` as a file watching tool than explain a bunch of caveats regarding the built-in watch support. But by all means experiment and [report back](https://github.com/michaelsbradleyjr/node-clojurescript/issues).\n\n### What's Next?\n\nSo now what you should do is read up on Clojure and ClojureScript and *get to busy!* &nbsp;See the *[Resources](#resources)* section below.\n\n## Prerequisites\n\n### Java\n\nThis library wraps a NodeJS front-end around the ClojureScript compiler, which is written in the Clojure language, which is hosted on the [Java Virtual Machine](http://en.wikipedia.org/wiki/Java_virtual_machine) (JVM). That means you *must* have Java setup to successfully install `clojure-script` with npm.\n\nMore specifically, you'll need JDK 1.6 (Java SE 6): &nbsp;[Windows](http://www.oracle.com/technetwork/java/javase/downloads/index.html), &nbsp;[Mac](https://developer.apple.com/library/mac/#documentation/Java/Conceptual/Java14Development/02-JavaDevTools/JavaDevTools.html), &nbsp;[debian / ubuntu](https://github.com/flexiondotorg/oab-java6)\n\nYou'll also need to export the proper value for `JAVA_HOME` into your environment. The [installation instructions](https://github.com/nearinfinity/node-java) for the `node-java` package are quite helpful in this regard, though note that installing `clojure-script` with npm will automatically install `node-java` as well (i.e. you don't need to do that separately).\n\n\n### NodeJS\n\nIf you're new to NodeJS and don't have it setup, that will be your next step. I highly recommend Tim Caswell's [Node Version Manager](https://github.com/creationix/nvm) (nvm). It's easy to install and, and makes working with multiple `node` versions dead simple. For example:\n\n```bash\n$ nvm install v0.6.17\n...\n$ nvm install v0.6.10\n...\n$ nvm use v0.6.17\n```\n\nWhen you install `node`, the `npm` tool will get installed along with it. So as long you have Java in place (see above), you should be ready to run:\n\n```bash\n$ npm install -g clojure-script\n```\n\nThat's it! Installing `clojure-script` (the npm package name for this library) will automatically perform a package-localized installation of Clojure, ClojureScript, Google Closure Compiler, etc.\n\nIf you get an error during installation, look closely at the error message. Maybe you made a typo while following the steps above? If you can't figure it out, feel free to submit an [issue](https://github.com/michaelsbradleyjr/node-clojurescript/issues).\n\n\n## NodeJS `require` support\n\nWith a local (vs. global) `node_modules` installation of `clojure-script`, you can load `.cljs` modules from other scripts without having to compile them beforehand.\n\nWith respect to the *[Quick Start](#quick-start)* examples above: create a script `other.js` in the same directory as `hello.cljs`, then paste in the following and save it:\n\n```javascript\nrequire('clojure-script');\n\nrequire('./hello');\n// or require('./hello.cljs');\n```\n\nThen you can do:\n\n```bash\n$ node other.js\n```\n\n**<span style=\"color:red;\">N.B.</span>** This is a handy feature for development purposes. But it would be a terrible idea to publish a package on the npm registry which makes use of this technique. Modules *developed* in ClojureScript should be *published* with *only* compiled JavaScript loaded at runtime (via NodeJS's `require`).\n\n### Remote builds and `require`\n\nIt's entirely possible to leverage the `require` support in combination with node-clojurescript's client-server mode described in the *[Faster, faster!](#faster-faster)* section above.\n\nSuppose you have a \"detached\" JVM server process running on port `8888`:\n\n```bash\n$ ncljsc --server 8888\n```\n\nIn your `.js` script you can then indicate:\n\n```javascript\nrequire('clojure-script')(8888);\n\nrequire('./hello.cljs');\n```\n\nIn this context, the client-logic makes a *synchronous* (not async) build request against the server process. `hello.cljs` will be transparently compiled and loaded as before, but more quickly.\n\nYou can call the function returned by `require` without arguments, like so:\n\n```javascript\nrequire('clojure-script')();\n...\n```\n\nIn that case, the port number will default to `4242` (make sure the server process is using the same port). Note that calling the function without arguments and *not* calling it are two distinct things. If you don't call it, the `clojure-script` module will start a new JVM and perform a local build. If you do call it, with or without arguments, a JVM will *not* be started and the module will make a remote build request.\n\n## Namespaces\n\nClojure and ClojureScript support the notion of [namespaces](http://clojure.org/namespaces). Unlike loading [modules](http://nodejs.org/api/modules.html) with NodeJS's `require`, using ClojureScript's namespace `:require` will result in the namespaced module being *inlined* as part of the compiled JavaScript (scope is carefully preserved).\n\nTry creating two scripts, `foo.cljs` and `bar.cljs`:\n\n**foo.cljs**\n```clojure\n(ns foo\n  (:require [cljs.nodejs :as nodejs]\n            [bar :as bar]))\n\n(defn ^:export greet [name, title]\n  (str \"Hello, \" (bar/title title) \" \" name))\n```\n**bar.cljs**\n```clojure\n(ns bar\n  (:require [cljs.nodejs :as nodejs]))\n\n(defn ^:export title [t]\n  (str t \" Amazing\" ))\n```\n\nNow create a third script, `greet.js`:\n\n**greet.js**\n```javascript\nvar foo = require('./compiled.js').foo;\n\nconsole.log(foo.greet('ClojureScript developer!', 'Mr.'));\n```\n\nTime to compile:\n\n```bash\n$ ncljsc -c -p foo.cljs > compiled.js\n```\n\nWhen that's finished, it's time to run `greet.js`:\n\n```bash\n$ node greet.js\nHello, Mr. Amazing ClojureScript developer!\n```\n\nExamining the plentiful contents of `compiled.js`, you'll see (toward the bottom) that both `foo.cljs` and `bar.cljs` were compiled into the stand-alone JS file.\n\n## Bundled Leiningen\n\n[Leiningen](https://github.com/technomancy/leiningen) is a popular and flexible build tool in wide use among Clojure developers. node-clojurescript bundles the shell script front-end to Leiningen (the `lein` command) and proxies to it with an executable script named `nlein`.\n\nIf you've installed the `clojure-script` module globally with `npm install -g clojure-script`, then you should be able to run:\n\n```bash\n$ nlein\n```\n\n`nlein` is a simple proxy script and does not feature any customizations of Leiningen. If you already have a `lein` executable on your path, `nlein` will ask whether it should delegate to it, with the option to remember your decision.\n\nNote that `nlein`, when it's not delegating to another `lein`, will store JAR files and other things it downloads in the `support/.lein` directory, relative to the root of the `clojure-script` package. This is to keep `nlein` from even potentially conflicting with an existing installation. Normally, `lein` stores such things in `$HOME/.lein`.\n\nAll in all, the purpose of `nlein` is to provide an easy way for NodeJS developers to get up and running with Leiningen. If you're already using Leiningen, you may choose to ignore `nlein` and go about your business as usual.\n\n## Coming Soon\n\nThere are several goals that need to be accomplished in short order:\n\n* The tooling developed in CoffeeScript needs to be re-implemented in ClojureScript so that this library will be pseudo self-hosting.\n* A plugin for the Leiningen build tool needs to be adapted or written, for use in development of complex ClojureScript projects in conjunction with this library and other NodeJS modules.\n* Missing features of `ncljsc` need to be implemented, the most important being a [REPL](https://github.com/clojure/clojurescript/wiki/The-REPL-and-Evaluation-Environments).\n* More and better documentation and examples.\n\nHelp in accomplishing these and future goals is more than welcome.\n\n## Resources\n\n```bash\n$ ncljsc --help\n```\n\n[ClojureScript: Translations from JavaScript](http://himera.herokuapp.com/synonym.html)\n\n[ClojureDocs](http://clojuredocs.org), &nbsp;[Clojure.org](http://clojure.org)\n\n[NodeJS Documentation](http://nodejs.org/api)\n\n[Leiningen](https://github.com/technomancy/leiningen), [wiki](https://github.com/technomancy/leiningen/wiki)\n\nGoogle Groups: [clojure](https://groups.google.com/forum/?fromgroups#!forum/clojure), &nbsp;[nodejs](https://groups.google.com/forum/?fromgroups#!forum/nodejs)\n\n`#clojure`, `#clojurescript` and `#node.js` channels on Freenode IRC.\n\n[prelude](https://github.com/bbatsov/prelude), &nbsp;[prelude-modules](https://github.com/bbatsov/prelude-modules), &nbsp;and [Emacs for OS X](http://emacsformacosx.com/) (latest pretest)\n\n## Credit\n\nThis software is derived from and incorporates existing works:\n\n[CoffeeScript](https://github.com/jashkenas/coffee-script),&nbsp; [ClojureScript](https://github.com/clojure/clojurescript),&nbsp; [Pomegranate](https://github.com/cemerick/pomegranate)\n\nIn particular, many thanks are owed to [Jeremy Ashkenas](https://github.com/jashkenas) and the other [CoffeeScript](https://github.com/jashkenas/coffee-script) maintainers. Using the CoffeeScript tooling as a template, it was possible to whip together a useable NodeJS front-end in one intense week. It would have otherwise been much more slow-going.\n\n## Copyright and License\n\nThis software is Copyright (c) 2012 by Michael Bradley, Jr.\n\nThe use and distribution terms for this software are covered by the [Eclipse Public License 1.0](http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file [epl-v10.html](http://michaelsbradleyjr.github.com/node-clojurescript/licenses/epl-v10.html) under the [licenses directory](https://github.com/michaelsbradleyjr/node-clojurescript/tree/master/licenses) at the root of this distribution. By using this software in any fashion, you are agreeing to be bound by the terms of this license. You must not remove this notice, or any other, from this software.\n\n---------------------------------------\n\n<a href=\"https://developer.mozilla.org/en/JavaScript/Reference/\" title=\"JavaScript Reference\">\n  <img src=\"http://static.jsconf.us/promotejshs.png\" alt=\"JavaScript Reference\" />\n</a>\n",
  "readmeFilename": "README.md",
  "_id": "clojure-script@0.1.4",
  "_from": "clojure-script@"
}
